{"ast":null,"code":"var _objectSpread = require(\"/home/nurchulis/Documents/WORK/Web/PROperty/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _regeneratorRuntime = require(\"/home/nurchulis/Documents/WORK/Web/PROperty/node_modules/@babel/runtime/regenerator\");\n\nvar DEFAULT_BASE = 1000;\nvar DEFAULT_PRECISION = 2;\nvar DEFAULT_DECIMAL_SEPARATOR = '.';\nvar ERROR_INVALID_VALUE = 'Value must be a valid number';\nvar ERROR_UNSAFE_VALUE = 'Value is either too big or too small';\nvar ERROR_INFINITE_VALUE = 'Value must be a finite number';\nvar ERROR_INVALID_PRECISION = 'Precision must be a non-negative integer';\nvar ERROR_INVALID_UNITS = 'Units must be an array';\nvar UNIT_THOUSAND = 'K';\nvar UNIT_MILLION = 'M';\nvar UNIT_BILLION = 'B';\nvar UNIT_TRILLION = 'T';\nvar UNIT_QUADRILLION = 'P';\nvar UNIT_QUINTILLION = 'E';\nvar defaultOptions = {\n  base: DEFAULT_BASE,\n  precision: DEFAULT_PRECISION,\n  decimalSeparator: DEFAULT_DECIMAL_SEPARATOR,\n  lowerCase: false,\n  space: false,\n  units: ['', UNIT_THOUSAND, UNIT_MILLION, UNIT_BILLION, UNIT_TRILLION, UNIT_QUADRILLION, UNIT_QUINTILLION]\n  /**\n   * parseValue ensures the value is a number and within accepted range.\n   *\n   * @param {number} value\n   */\n\n};\n\nvar parseValue = function parseValue(value) {\n  var val = parseFloat(value);\n\n  if (Number.isNaN(val)) {\n    throw new Error(ERROR_INVALID_VALUE);\n  }\n\n  if (val > Number.MAX_SAFE_INTEGER || val < Number.MIN_SAFE_INTEGER) {\n    throw new RangeError(ERROR_UNSAFE_VALUE);\n  }\n\n  return val;\n};\n/**\n * divider is a generator that divides a value by a denominator defined\n * by the grouping base (default 1000). Each successive turn multipies\n * the base by itself, resulting in a decimal and a unit (count).\n *\n * @param {number} value - Number to be divided\n * @param {number} base - Grouping base/interval\n */\n\n\nvar divider =\n/*#__PURE__*/\n_regeneratorRuntime.mark(function divider(value, base) {\n  var denominator, count, result;\n  return _regeneratorRuntime.wrap(function divider$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          denominator = base;\n          count = 0;\n\n        case 2:\n          if (!true) {\n            _context.next = 11;\n            break;\n          }\n\n          result = value / denominator;\n\n          if (!(result < 1)) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\");\n\n        case 6:\n          _context.next = 8;\n          return {\n            result: result,\n            count: ++count // Increase the denominator each turn\n\n          };\n\n        case 8:\n          denominator *= base;\n          _context.next = 2;\n          break;\n\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, divider);\n});\n/**\n * round up a number to specified precision\n *\n * @param {number} value - Number to be rounded\n * @param {number} precision - Significant places\n */\n\n\nvar round = function round(value, precision) {\n  if (!Number.isFinite(value)) {\n    throw new Error(ERROR_INFINITE_VALUE);\n  }\n\n  if (!Number.isInteger(precision) || precision < 0) {\n    throw new Error(ERROR_INVALID_PRECISION);\n  }\n\n  if (Number.isInteger(value)) {\n    return value;\n  }\n\n  return parseFloat(value.toFixed(precision));\n};\n/**\n * Millify converts long numbers to human-readable strings.\n *\n * @param {number} value - Number to convert\n * @param {Object} options\n * @param {number} options.precision - Number of significant figures\n * @param {string} options.decimalSeparator - Type of decimal marker\n * @param {boolean} options.lowerCase - Lowercase units\n * @param {boolean} options.space - Space between number and abbreviation\n * @param {number} options.base - Numerical group\n * @param {Array<string>} options.units - List of units\n */\n\n\nvar Millify = function Millify(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // Override default options with supplied ones\n  var opts = _objectSpread({}, defaultOptions, options);\n\n  if (!Array.isArray(opts.units) || !opts.units.length) {\n    throw new Error(ERROR_INVALID_UNITS);\n  } // Validate value for type and length\n\n\n  var val = parseValue(value); // Add a minus sign (-) prefix if it's a negative number\n\n  var prefix = val < 0 ? '-' : ''; // Work with positive values\n\n  val = Math.abs(val); // Keep dividing the input value by the numerical grouping value (base)\n  // until the decimal and unit is deciphered\n\n  var unit = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = divider(val, opts.base)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var div = _step.value;\n      val = div.result;\n      unit = div.count;\n    } // Avoid out of bounds error by using the last available unit\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  unit = unit > opts.units.length ? opts.units.length - 1 : unit; // Calculate the unit suffix and apply lowercase option\n\n  var suffix = opts.lowerCase ? opts.units[unit].toLowerCase() : opts.units[unit]; // Add a space between number and abbreviation\n\n  var space = opts.space ? ' ' : ''; // Round decimal up to desired precision\n\n  var rounded = round(val, opts.precision); // Replace decimal mark if desired\n\n  var formatted = rounded.toString().replace(DEFAULT_DECIMAL_SEPARATOR, opts.decimalSeparator);\n  return \"\".concat(prefix).concat(formatted).concat(space).concat(suffix);\n};\n\nmodule.exports = Millify;","map":null,"metadata":{},"sourceType":"script"}